#' clipping_lidar_buildings_opPlot Function
#'
#' This function is responsible for making the clip of a lidar file for each of the
#' potential roofs to develop hubs for air taxis. The function has the option of
#' plotting each of the terraces in 3D in order to have a better visualization of
#' the cloud of 3D points.
#' This function returns a list with each of the Lidar files (.las),
#' which are the results of the clip made to each of the buildings. The user can specify
#' a specific route or if not assigned, the results will be stored in the tempdir folder
#' @name clipping_lidar_buildings_opPlot
#' @importFrom lidR readLAS lasclip writeLAS plot
#' @importFrom sf st_read
#' @importFrom graphics plot
#' @keywords lidar, shapefile, rooftops, plot, buildings, clip
#' @param path_lidar_file This is the path which contains the main Lidar file (.las)
#' @param path_shp_buildings This is the path that contains the shapefile file with each of the roofs of the buildings.
#' @param path_folder_save This is the directory path where the user wishes to save the cut lidar files for each of the buildings (roofs), This is the directory path where the user wishes to save the cut lidar files for each of the buildings (roofs), if the parameter is empty the results will be stored in the tempdir folder
#' @param make_plot This is a Boolean option which evaluates whether or not the user wishes to plot the lidar files generated after the clip operation with the buildings.
#' @param name_id_field This is an optional parameter where the user can specify which field identifies the shapefile of the buildings. The value of this field will be the identifier for each of the generated files.
#' @return list_new_las It is a list which contains each of the .las files generated by cutting the main lidar file with the roofs from the shapefile
#' @examples
#' path_las <- system.file("extdata/new_lidar.las", package = "RooftopsHubsAnalyisisLidar")
#' sample_rooftops_print <- system.file("extdata/sample_roofs.shp", package = "RooftopsHubsAnalyisisLidar")
#' list_las_elements <- clipping_lidar_buildings_opPlot(path_las, sample_rooftops_print)
#' @export


clipping_lidar_buildings_opPlot<- function(path_lidar_file, path_shp_buildings, path_folder_save="", make_plot = TRUE, name_id_field = ""){

  shp_buildings <- sf::st_read(path_shp_buildings)
  las_file <- lidR::readLAS(path_lidar_file)
  i <- 1
  val_validation <- ""
  list_new_las <- c()

  #verification if the field submitted by user exits or not
  if(name_id_field != ""){
    val_validation <- verify_id_field(path_shp_buildings, name_id_field)
  }else{
    #this case apply when the user dosen't submit any name of a field to identiy the features
    #the function verify if it exists the default names OBJECTID and FIS from a typical shapefile
    val_objid <- verify_id_field(path_shp_buildings, "OBJECTID")
    if (val_objid == FALSE){
      val_fid <- verify_id_field(path_shp_buildings, "FID")
      if (val_fid == FALSE){
        val_validation <- FALSE
      }else{
        val_validation <- TRUE
        #Case when the id field is FID
        #verification if the crs of both lidar file and shape file are the same
        #in case they are not the same, the lidar file is being reprojected using the epsg from the shapfile

        epsg_las <- epsg(las_file)
        print(epsg_las)

        epsg_shp <- sf::st_crs(shp_buildings)$epsg
        print(epsg_shp)

        if (is.na(epsg_shp)){
          sf::st_crs(shp_buildings)$epsg <- 26918
          epsg_shp <- 26918
        }

        if (epsg_las != epsg_shp){
          print("The sources have different epsg")
          #Get the epsg from the shp file and add it to a new variable
          crs <- sp::CRS(paste("+init=epsg:","26918", sep=""))
          lidR::projection(las_file) <- crs
          print("Las file projected...")
          #projection(las_file)
        }else{
          print("The epsg of both sources matched")
        }

        #verify_proj_CRS_lidar_building(path_lidar_file, path_shp_buildings)

        #For loop to iterate each one of the rows or feature inside of shp in order to stablish the clip with the lidar file
        for (row in 1:(dim(shp_buildings)[1])){

          fid_shp <- shp_buildings$FID[i]
          print(paste("Working in the building with the id:",fid_shp, sep="" ))
          subset_shp <- subset(shp_buildings, FID==fid_shp)
          i <- i+1
          subset_las <- lidR::lasclip(las_file, subset_shp)

          if (path_folder_save != ""){

            print("Saving in the selected folder...")
            nameFile <- paste("las_", fid_shp, sep="")
            complete_path <- paste(path_folder_save, "/", nameFile, ".las", sep="")
            writeLAS(subset_las, complete_path)
            list_new_las <- append(list_new_las, complete_path)
            print("Saved")

            if (make_plot == TRUE){
              print("Generating the plots...")
              plot(subset_las)
            }

          }else if (path_folder_save == ""){

            print("Saving in the temporal folder by default...")
            nameFile <- paste("las_", fid_shp, sep="")
            complete_path <- paste(tempdir(), "/", nameFile, ".las", sep="")
            writeLAS(subset_las, complete_path)
            list_new_las <- append(list_new_las, complete_path)
            print("Saved")

            if (make_plot == TRUE){
              print("Generating the plots...")
              plot(subset_las)
            }

          }else{
            print("The clips are not being saved...")
          }
          #clean memory
          gc()
        }
      }
    }else{
      val_validation <- TRUE

      #Case when the id field is OBJECTID
      #verification if the crs of both lidar file and shape file are the same
      #in case they are not the same, the lidar file is being reprojected using the epsg from the shapfile

      epsg_las <- lidR::epsg(las_file)
      epsg_shp <- sf::st_crs(shp_buildings)$epsg
      print(epsg_shp)
      print(epsg_las)
      print(las_file)

      if (is.na(epsg_shp)){
        print("Case when it is na")
        sf::st_crs(shp_buildings)$epsg <- 26918
        epsg_shp <- 26918
      }

      if (epsg_las != epsg_shp){
        print("The sources have different epsg")
        #Get the epsg from the shp file and add it to a new variable
        crs <- sp::CRS(paste("+init=epsg:","26918", sep=""))
        lidR::projection(las_file) <- crs
        print("Las file projected...")
        #projection(las_file)
      }else{
        print("The epsg of both sources matched")
      }
      print(sf::st_crs(shp_buildings)$epsg)
      print(lidR::epsg(las_file))

      print("before clip")
      print(las_file)

      #verify_proj_CRS_lidar_building(path_lidar_file, path_shp_buildings)

      #For loop to iterate each one of the rows or feature inside of shp in order to stablish the clip with the lidar file
      for (row in 1:(dim(shp_buildings)[1])){

        fid_shp <- shp_buildings$OBJECTID[i]
        print(paste("Working in the building with the id:",fid_shp, sep="" ))
        subset_shp <- subset(shp_buildings, OBJECTID==fid_shp)
        print("Subset")
        print(subset_shp)
        print(las_file)

        subset_las <- lidR::lasclip(las_file, subset_shp)
        print("Subset_las")
        print(subset_las)

        if (path_folder_save != ""){

          print("Saving in the selected folder...")
          nameFile <- paste("las_", fid_shp, sep="")
          complete_path <- paste(path_folder_save, "/", nameFile, ".las", sep="")
          lidR::writeLAS(subset_las, complete_path)
          list_new_las <- append(list_new_las, complete_path)
          print("Saved")

          if (make_plot == TRUE){
            print("Generating the plots...")
            lidR::plot(subset_las)
          }

        }else if (path_folder_save == ""){

          print("Saving in the temporal folder by default...")
          nameFile <- paste("las_", fid_shp, sep="")
          complete_path <- paste(tempdir(), "/", nameFile, ".las", sep="")
          lidR::writeLAS(subset_las, complete_path)
          list_new_las <- append(list_new_las, complete_path)
          print("Saved")

          if (make_plot == TRUE){
            print("Generating the plots...")
            lidR::plot(subset_las)
          }

        }else{
          print("The clips are not being saved...")
        }
        i <- i+1
        #clean memory
        gc()
      }

    }
  }

  if (val_validation == FALSE){
    print("Please verify the field selected which has the id of each feature")
  }

  return(list_new_las)
}

#' verify_id_field Function
#'
#' Function to verify if the field provided by the user exists or not.
#' @name verify_id_field
#' @importFrom raster shapefile
#' @param path_shp_buildings Path of the shapefile to perform the validation
#' @param name_id_field Name of the field to verify if it exits within the shapefile
#' @export

verify_id_field <- function(path_shp_buildings, name_id_field){
  shp_buildings <- shapefile(path_shp_buildings)
  #list of attributes from the shapefile
  print("Verifying...")
  l <-  base::names(shp_buildings)
  validation <- name_id_field %in% l
  return(validation)
}

#' verify_proj_CRS_lidar_building Function
#'
#' Function that verifies if the lidar file and the shapefile have the same coordinate system
#' @name verify_proj_CRS_lidar_building
#' @importFrom lidR readLAS epsg projection
#' @importFrom sf st_read st_crs
#' @importFrom sp CRS
#' @importFrom sf st_crs
#' @param path_lidar_file Path of the lidar file (.las) to perform the validation
#' @param path_shp_buildings Path of the shapefile to perform the validation
#' @export

verify_proj_CRS_lidar_building <- function(path_lidar_file, path_shp_buildings){
  las_file <- readLAS(path_lidar_file)
  epsg_las <- epsg(las_file)
  print(epsg_las)

  shp_buildings <- sf::st_read(path_shp_buildings)
  epsg_shp <- sf::st_crs(shp_buildings)$epsg
  print(epsg_shp)

  if (is.na(epsg_shp)){
    sf::st_crs(shp_buildings)$epsg <- 26918
    epsg_shp <- 26918
  }

  if (epsg_las != epsg_shp){
    print("The sources have different epsg")
    #Get the epsg from the shp file and add it to a new variable
    crs <- sp::CRS(paste("+init=epsg:","26918", sep=""))
    lidR::projection(las_file) <- crs
    print("Las file projected...")
    #projection(las_file)
  }else{
    print("The epsg of both sources matched")
  }
}

#' dist_heigh_boxplots_lidar Function
#'
#' Function to plot the boxplots of the heights of each building
#' @name dist_heigh_boxplots_lidar
#' @importFrom lidR readLAS
#' @import stringr
#' @param list_elements_lidar List with the generated lidar files to perform the boxplot of each one of them
#' @examples
#' library(ggplot2)
#' path_folder_las <- system.file("extdata/sample_las", package = "RooftopsHubsAnalyisisLidar")
#' list_las <- base::list.files(path_folder_las,full.names = TRUE)
#' dist_heigh_boxplots_lidar(list_las)
#' @export

dist_heigh_boxplots_lidar <- function(list_elements_lidar){

  dframe <- data.frame(plot_id = NA, Z = NA)
  dframe_output <- data.frame(boxp_id = NA, name_file = NA)

  for (i in list_elements_lidar) {
    las <- readLAS(i)
    Z <- data.frame(Z = las@data$Z)
    name_file = stringr::str_remove(basename(i), ".las")
    plot_id <- data.frame(plot_id = rep.int(which(list_elements_lidar == i), nrow(Z)))
    boxp_id <- which(list_elements_lidar == i)
    las_frame <- cbind(plot_id, Z)
    r_frame_output <- cbind(boxp_id, name_file)
    dframe <- rbind(dframe, c(las_frame))
    dframe_output <- rbind(dframe_output, c(r_frame_output))
  }

  #remove the first column implemented when creating the dataframe
  dframe <- dframe[-1,]
  rm(i, list_elements_lidar, las, Z, plot_id, las_frame)

  dframe_output <- dframe_output[-1,]
  dframe = subset(dframe, dframe$Z > 1)

  print(dframe_output)

  #ggplot takes the dataframe and build a boxplot for each building
  ggplot2::ggplot(dframe, aes(x = factor(plot_id), y = Z)) +
    ggtitle("Boxplots for height distribution of the potential buildings") +
    geom_boxplot(outlier.size = 1, fill='lightblue', color="black") +
    xlab("ID Building") +
    ylab("Height (m)") +
    scale_y_continuous(limits = c(1, 33), breaks = c(seq(1, 33, 4))) +
    theme_bw() +
    theme(panel.border = element_rect(colour = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          legend.position = "none")
}

#' dist_heigh_histogrmas_lidar Function
#'
#' Function to plot the histograms of the heights for each building
#' @name dist_heigh_histogrmas_lidar
#' @importFrom lidR readLAS
#' @param list_elements_lidar List with the generated lidar files to perform the histograms of each one of them
#' @examples
#' library(ggplot2)
#' library(stringr)
#' path_folder_las <- system.file("extdata/sample_las", package = "RooftopsHubsAnalyisisLidar")
#' list_las <- base::list.files(path_folder_las,full.names = TRUE)
#' dist_heigh_histogrmas_lidar(list_las)
#' @export

dist_heigh_histogrmas_lidar <- function(list_elements_lidar){

  dframe <- data.frame(plot_id = NA, Z = NA)
  dframe_output <- data.frame(boxp_id = NA, name_file = NA)

  #evaluating the size of the matrix will have the layout of the plots
  num_ele <- length(list_elements_lidar)
  fact_ele <- num_ele/4
  num_cols <- 0
  num_rows <- 0
  if (num_ele%%2 == 0){
    num_rows <- fact_ele
    num_cols <- 4
  }else{
    num_rows <- floor(fact_ele)+1
    num_cols <- 4
  }


  for (i in list_elements_lidar) {
    las <- readLAS(i)
    Z <- data.frame(Z = las@data$Z)
    name_file = stringr::str_remove(basename(i), ".las")
    plot_id <- data.frame(plot_id = rep.int(which(list_elements_lidar == i), nrow(Z)))
    boxp_id <- which(list_elements_lidar == i)
    las_frame <- cbind(plot_id, Z)
    r_frame_output <- cbind(boxp_id, name_file)
    dframe <- rbind(dframe, c(las_frame))
    dframe_output <- rbind(dframe_output, c(r_frame_output))
  }

  dframe <- dframe[-1,]
  rm(i, list_elements_lidar, las, Z, plot_id, las_frame)
  dframe_output <- dframe_output[-1,]

  min(dframe$Z)
  max(dframe$Z)

  print(dframe_output)

  ggplot2::ggplot(dframe, aes(x = Z)) +
    ggtitle("Histograms for height distribution of the potential buildings") +
    geom_vline(xintercept = 1, color = 'red', linetype = 2) +
    geom_histogram(breaks = seq(-1, 33, 2),
                   binwidth = 2,
                   aes(y = ..count..),
                   colour = "black",
                   fill = "lightblue") +
    scale_y_continuous("Count of 3d cloud points", limits = c(0, 600)) +
    scale_x_continuous("Height (m)", limits = c(-1, 33)) +
    facet_wrap(~plot_id, ncol = num_cols, nrow = num_rows) +
    theme_bw() +
    theme(strip.background = element_blank(),
          panel.border = element_rect(colour = "black"),
          legend.position = "none",
          plot.title = element_text(hjust = 0.5))

}


#' buildings_grid_metrics_lidar Function
#'
#' Function to plot the mean of the elevations as a grid object
#' @name buildings_grid_metrics_lidar
#' @importFrom lidR readLAS grid_metrics
#' @importFrom rasterVis levelplot
#' @importFrom grDevices colorRampPalette
#' @param list_elements_lidar List with the generated lidar files to perform the metric statistics plots of each one of them
#' @param size_pixel Desired pixel size to estimate the average heights in each of the buildings, Default 5m
#' @examples
#' library(RColorBrewer)
#' library(stringr)
#' path_folder_las <- system.file("extdata/sample_las", package = "RooftopsHubsAnalyisisLidar")
#' list_las <- base::list.files(path_folder_las,full.names = TRUE)
#' buildings_grid_metrics_lidar(list_las)
#' @export

#Function to plot the mean of the elevations as a grid object
buildings_grid_metrics_lidar <- function(list_elements_lidar, size_pixel = 5){

  #evaluating the size of the matrix will have the layout of the plots
  num_ele <- length(list_elements_lidar)
  fact_ele <- num_ele/4
  num_cols <- 0
  num_rows <- 0
  list_plots <- c()

  if (num_ele%%2 == 0){
    num_rows <- fact_ele
    num_cols <- 4
  }else{
    num_rows <- floor(fact_ele)+1
    num_cols <- 4
  }

  count_var <- 1
  colr <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(11, 'RdYlBu'))

  for(i in list_elements_lidar){
    las <- readLAS(i)
    name_file = stringr::str_remove(basename(i), ".las")
    q <- grid_metrics(las, mean(Z), size_pixel)
    plot_grid <- levelplot(q, xlab=NULL, ylab=NULL, margin=FALSE, col.regions=colr, main=list(toString(count_var),cex=0.75))
    list_plots[[count_var]] <- plot_grid
    count_var <- count_var +1
  }

  gridExtra::grid.arrange(grobs = list_plots, ncol=num_cols, nrow=num_rows)

}
